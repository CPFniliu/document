# 知识体系

## Base

### 设计模式

#### 创建型模式

##### 单例模式

1. 饿汉式, 懒汉式, 枚举式, 内部类懒汉式, 登记注册式.
2. dcl 问题
3. 反射破解, 反序列化破解, 反克隆

##### 工厂模式

1. 工厂方法模式
2. 简单工厂
3. 抽象工厂

#### 结构性模式

##### Proxy 代理模式

静态代理
JDK动态代理
CGlib动态代理

##### Strategy

##### Template

##### Delegate

## 并发编程

### Java 内存模型

#### 线程通信

#### 消息传递

### 内存模型

#### 重排序

#### 顺序一致性

#### Happens-Before

#### As-if-Serial

### Synchronized

monitor, 对象头, mark word

#### 同步, 重量级锁

#### Synchronized原理

#### 锁优化

轻量级锁, 偏向锁, 自旋锁, JIT编译优化, 去除锁, 整理锁

### Volatile

#### 实现机制

#### 内存语义

#### Volatile内存模型

### 并发基础

#### AQS

##### AbstractQueuedSynchronizer 同步器

##### CLH 同步队列

##### 同步状态的获取和释放

##### 线程的阻塞和唤醒

#### CAS

##### ABA 问题

### 锁

#### Reentrantlock

#### ReentrantReadWriteLock

#### Condition

### 相关开发工具类

#### Cyclicbarrier

#### CountDownLatch

#### Semphore

#### ArrayBlockingQueue

#### LinkedBlockingQueue

### 并发集合

#### ConCurrentHashMap

#### ConCurrentLinkedQueue

### 基础原子类

#### 基本类型

##### AtomicBoolean

##### AtomicInteger

##### AtomicLong

#### 数组

##### AtomicIntegerArray

##### AtomicLongArray

##### AtomicReferenceArray

#### 引用类型

##### AtomicReference

##### AtomicReferenceFieldUpdater

### 线程池

#### Executor

#### ThreadPoolExecutor

#### Callable 和 Future

#### ScheduledExecturservice

### other

#### ThreadLocal

#### Fork/Join

## 性能优化

### 基础

#### 性能基准

#### 什么是性能优化

#### 衡量维度

### JVM 调优

#### JVM 运行数据区

#### JVM 内存模型

#### 垃圾回收机制及使用场景

#### GC日志

#### 实战Mat分析Dump

### tomcat 调优

#### tomcat运行机制和框架

#### tomcat线程模型

#### tomcat 系统参数以及认识调优

#### 基准测试

### Mysql调优

#### B+ tree

#### SQL 执行计划

#### 索引优化详解

#### Sql语句优化

---

## frame work

### Spring5

#### 基础知识

##### IOC & DI

##### AOP

#### Beans

##### 生命周期

##### 接口实例化

#### Context

##### Factory

##### BeanFactory & FactoryBean

#### Transaction

##### 生命式事务原理

##### 事务处理机制

##### 事务级别和传播行为

##### 事务监控

#### SpringMVC

##### MVC 流程

##### 整合IOC容器

##### HandlerMapping 实现原理

##### ViewResolver 实现原理

##### Controller 调用原理

##### 动态参数匹配原理

##### 与 Struts2对比

#### Spring5 新特性

### Mybatis

#### 使用方式

#### 1 对 1, 1对多, 多对多, 嵌套结果, 嵌套查询

#### 一级缓存, 二级缓存使用场景和选择策略

#### 集成到 Spring

#### Mybatis 事务

#### Mybatis 动态代理实现

#### Generator 生成代码

---

## 分布式架构

### 分布式架构基础知识

#### 分布式架构意义

#### 分布式架构演进过程

#### 构建分布式框架重要因素

##### CND 加速静态文件访问

##### 分布式存储

##### 分布式搜索引擎

##### 应用发布和监控

##### 应用容灾和机房规划

##### 系统动态扩容

#### 分布式架构设计

##### Soa 架构

##### 微服务架构

##### 领域驱动模型划分DDD

##### 分布式架构基本理论CAP, BASE

##### 分布式架构下的高可用性设计

##### 分布式架构下的可伸缩设计

##### 高性能的分布式架构





---

## 开发管理工具

### Maven

#### 可执行jar

#### Scope

#### 类冲突, 包依赖, NoClassFoundError 问题定位

#### Maven 生命周期, Phase, Goal

#### 自定义 Atchetype

#### Nexus 使用,上传,配置

### Gradle

### Jenkins

#### 持续集成, 一次build后解决所有手动工作

### Sonar

#### 减少人为疏漏, 静态代码检查

### Git

#### 工作原理

#### 常用命令

#### Git 冲突




用户多，不代表你服务器访问量大，访问量大不一定你服务器压力大！我们换成专业点的问题，高并发下怎么优化能避免服务器压力过大？

1，整个架构:可采用分布式架构，利用微服务架构拆分服务部署在不同的服务节点，避免单节点宕机引起的服务不可用！



2，数据库:采用主从复制，读写分离，甚至是分库分表，表数据根据查询方式的不同采用不同的索引比如b tree，hash，关键字段加索引，sql避免复合函数，避免组合排序等，避免使用非索引字段作为条件分组，排序等！减少交互次数，一定不要用select *！

3，加缓存:使用诸如memcache，redis，ehcache等缓存数据库定义表，结果表等等，数据库的中间数据放缓存，避免多次访问修改表数据！登录信息session等放缓存实现共享！诸如商品分类，省市区，年龄分类等不常改变的数据，放缓存，不要放数据库！

同时要避免缓存雪崩和穿透等问题的出现导致缓存崩溃！



4，增量统计:不要实时统计大量的数据，应该采用晚间定时任务统计，增量统计等方式提前进行统计，避免实时统计的内存，CPU压力！

5，加图片服务器:图片等大文件，一定要单独经过文件服务器，避免IO速度对动态数据的影响！保证系统不会因为文件而崩溃！

6，HTML文件，枚举，静态的方法返回值等静态化处理，放入缓存！

7，负载均衡:使用nginx等对访问量过大的服务采用负载均衡，实现服务集群，提高服务的最大并发数，防止压力过大导致单个服务的崩溃！



8，加入搜索引擎:对于sql中常出现的like，in等语句，使用lucence或者solr中间件，将必要的，依赖模糊搜索的字段和数据使用搜索引擎进行存储，提升搜索速度！#注意:全量数据和增量数据进行定时任务更新！

9，使用消息中间件:对服务之间的数据传输，使用诸如rabbit mq，kafka等等分布式消息队列异步传输，防止同步传输数据的阻塞和数据丢失！



10，抛弃tomcat:做web开发，接触最早的应用服务器就是tomcat了，但是tomcat的单个最大并发量只能不到1w！采取netty等actor模型的高性能应用服务器！

11，多线程:现在的服务器都是多核心处理模式，如果代码采用单线程，同步方式处理，极大的浪费了CPU使用效率和执行时间！



12，避免阻塞:避免bio，blockingqueue等常常引起长久阻塞的技术，而改为nio等异步处理机制！

13，CDN加速:如果访问量实在过大，可根据请求来源采用CDN分流技术，避免大流量完成系统崩溃！

14，避免低效代码:不要频繁创建对象，引用，少用同步锁，不要创建大量线程，不要多层for循环！

当然还有更多的细节优化技术！

欢迎工作一到五年的Java工程师朋友们加入Java架构开发：744677563

本群提供免费的学习指导 架构资料 以及免费的解答

不懂得问题都可以在本群提出来 之后还会有职业生涯规划以及面试指导
--------------------- 
作者：Java填坑之路 
来源：CSDN 
原文：https://blog.csdn.net/yelvgou9995/article/details/81589664 
版权声明：本文为博主原创文章，转载请附上博文链接！