# [***JVM 规范小结***](https://yq.aliyun.com/articles/619813?utm_content=m_1000008975)

> https://blog.csdn.net/tonytfjing/article/details/44278233

# 一、基础

1. 与 Java 语言
   JVM 与 Java 语言没有必然的联系，只与 class 文件格式有关联。

2. 与 .class 文件
   - class 文件包含了 Java 虚拟机指令集（字节码）和符号表，以及其他辅助信息。
   - JVM 在 class 文件中施加了许多强制性语法和结构化约束。
   - 凡是能用 class 文件正确表达出来的编程语言都可以在 JVM 中执行。

3. 数据类型
   - 原始类型（基本类型），如 int、double、long <---> 原始值
         ① 整数类型
            byte 8位有符号二进制补码整数，默认值为0（下面3个也是）
            short 16位有...
            int 32位有...
            long 64位有...
            char 16位无符号整数表示的、指向基本多文种平面（BMP）的 Unicode 码点，UTF-16 编码，默认为 null（'u0000'）
         ② 浮点数类型
            float 32位单精度（IEEE 754标准）
            double 64位单精度（IEEE 754标准）
         **五个特殊数值**：正数0、负数0、正无穷大、负无穷大、NaN
         除了 NaN 之外，其他值都是 有序的
         有且仅有一个值 NaN 与自身比较返回 false
         任何数字与 NaN 比较都会返回 false
         ③ returnAddress
            值指向虚拟机一个地址
         ④ boolean
         在编译之后一般使用 int 数据类型代替

   - 引用类型，如 reference <---> 引用值
         class type
         array type
         interface type
         数据最外维是 组件类型，最里面维度称为 元素类型。如List，其中List是组件类型，Integer是元素类型。
         顺便一提，Integer具有一个缓冲池 -128~127，默认情况下直接从池中取值（取的值相等则变量地址相同），除非 new Integer(10) 或者取超出范围的值。
> JVM 希望类型检查能在程序运行前（编译阶段）完成。

## 运行时数据区

   1. pc 寄存器
      每个 JVM 线程都有自己的 pc 寄存器
      每个线程只执行一个方法
      容量至少应当能保存一个 returnAddress 类型的数据或者一个与平台相关的本地指针的值

   2. 虚拟机栈
      StackOverflowError 线程请求分配的栈容量超过 JVM 栈允许的最大容量
      OutOfMemoryError 栈可以动态扩展，在尝试扩展时无法申请到足够的内存

   3. 堆
      是可供各个线程共享的 运行时内存区域
      是供所有类实例和数组对象 分配内存 的区域
      所使用的内存，不需要 保证是 连续 的
      抛出OutOfMemoryError

   4. 方法区
      是可供各个线程共享的 运行时内存区域
      包括【 运行时常量池，字段和方法数据，构造函数和普通方法的字节码内容，在类、实例、接口初始化时用到的特殊方法】
      抛出OutOfMemoryError

   6. 运行时常量池
      class 文件中每一个类或接口的常量池表
      抛出OutOfMemoryError

   7. 本地方法栈
      支持 native 的执行（其他语言编写的方法）
      抛出StackOverflowError
      抛出OutOfMemoreyError

## 帧栈

   存储数据和部分过程结果的数据结构
   也用来处理动态链接、方法返回值和异常分派
   随着方法调用而创建，随着方法结束而销毁
   为程序提供调试功能
   当前栈帧 - 当前类 - 当前方法
   （1）局部变量表
      索引访问
      long 和 double 的值占用两个连续的局部变量
   （2）操作数栈
      long 和 double 占用两个单位的栈深度
   （3）动态链接
      每个栈帧都包含一个指向当前方法所在类型的运行时常量池的引用
      晚期绑定？

6. 浮点运算
   1. JVM 的浮点操作
      - 遇到被0除、上下限溢出和非精确时，不会抛出错误
      - 不支持 IEEE 754 的信号浮点比较
      - 舍入操作：向最接近数舍入模式，如果无法精确，则舍入到最低有效位为 0 的那个值
      - 浮点数值 -> 整型数值：向零舍入
      - 不支持 IEEE 754 的单精度扩展和双精度扩展格式
   2. 浮点模式
      - 每个方法都有这项属性
      - 分为 FP-strict 模式、非FP-strict模式
      - 体现在 class 文件的方法 method_info 结构的访问标志 access_flags 中的 ACC_STRICT 标志位
      - JDk 1.1以及之前版本的编译器是 非FP-strict模式
   3. 数值集合转换
      - 支持扩展指数集合的 JVM 实现数值在标准浮点数集合与扩展指数集合之间饿映射关系是允许或必要的
      - float => 单精度浮点数集合中的元素
      - double => 双精度浮点数集合中的元素
7. 特殊方法
   （1） 构造方法（初始化方法）
   （2）签名多态性
   由 java.lang.invoke.MethodHandle 类进行声明
   只有一个类型为 Object[] 的形参
   返回值为 Object
   ACC_VARARGS 和 ACC_NATIVE 标志被设置
8. 异常
   1. 同步异常
      athrow 字节码指令被执行
      虚拟机同步检测到程序发生非正常的执行情况
   2. 异步异常
      调用了 Thread 或者 ThreadGroup 的 stop 方法
      JVM 实现发生了内部错误
      每个执行的方法都配备0~多个异常处理器
9. 类库
   需要JVM特殊支持的类
   反射：java.lang.reflect、Class
   加载和创建类或接口的类：ClassLoader
   连接和初始化类或接口：ClassLoader
   安全：java.security
   多线程：Thread
   弱引用：java.lang.ref
10. 公有设计、私有实现
   == 统一设计、各自实现

---

## 垃圾收集器与内存分配策略

   java栈、程序计数器、本地方法栈都是线程私有的，线程生就生，线程灭就灭，栈中的栈帧随着方法的结束也会撤销，内存自然就跟着回收了。所以这几个区域的内存分配与回收是确定的，我们不需要管的。但是java堆和方法区则不一样，我们只有在程序运行期间才知道会创建哪些对象，所以这部分内存的分配和回收都是动态的。一般我们所说的垃圾回收也是针对的这一部分。
   Stack的内存管理是顺序分配的，而且定长，不存在内存回收问题；而Heap 则是为java对象的实例随机分配内存，不定长度，所以存在内存分配和回收的问题

### 内存分配

   Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，减少了系统调用的次数，节省了一定的开销，这有点类似于内存池的概念；

   java一般内存申请有两种：

   **静态内存** : 编译时就能够确定的内存就是静态内存，即内存是固定的，系统一次性分配，比如int类型变量.

   **动态内存** : 动态内存分配就是在程序执行时才知道要分配的存储空间大小，比如java对象的内存空间。

### 垃圾检测方法

引用计数法 : 给一个对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1。(两个对象互相引用的情况则无法通过该方法标记)

可达性分析算法 : 以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象, 本地方法中引用的对象等。

### GC 回收算法

1.标记-清除（Mark-sweep）

算法和名字一样，分为两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。这是最基础的算法，后续的收集算法都是基于这个算法扩展的。

不足：效率低；标记清除之后会产生大量碎片。效果图如下：

2.复制（Copying）

此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。效果图如下：



3.标记-整理（Mark-Compact）

此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。效果图如下：



（1,2,3 图文摘自 http://pengjiaheng.iteye.com/blog/520228，感谢原作者。）

4.分代收集算法

这是当前商业虚拟机常用的垃圾收集算法。分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。

为什么要运用分代垃圾回收策略？在java程序运行的过程中，会产生大量的对象，因每个对象所能承担的职责不同所具有的功能不同所以也有着不一样的生命周期，有的对象生命周期较长，比如Http请求中的Session对象，线程，Socket连接等；有的对象生命周期较短，比如String对象，由于其不变类的特性，有的在使用一次后即可回收。试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，那么消耗的时间相对会很长，而且对于存活时间较长的对象进行的扫描工作等都是徒劳。因此就需要引入分治的思想，所谓分治的思想就是因地制宜，将对象进行代的划分，把不同生命周期的对象放在不同的代上使用不同的垃圾回收方式。

如何划分？将对象按其生命周期的不同划分成：年轻代(Young Generation)、年老代(Old Generation)、持久代(Permanent Generation)。其中持久代主要存放的是类信息，所以与java对象的回收关系不大，与回收息息相关的是年轻代和年老代。这里有个比喻很形象

“假设你是一个普通的 Java 对象，你出生在 Eden 区，在 Eden 区有许多和你差不多的小兄弟、小姐妹，可以把 Eden 区当成幼儿园，在这个幼儿园里大家玩了很长时间。Eden 区不能无休止地放你们在里面，所以当年纪稍大，你就要被送到学校去上学，这里假设从小学到高中都称为 Survivor 区。开始的时候你在 Survivor 区里面划分出来的的“From”区，读到高年级了，就进了 Survivor 区的“To”区，中间由于学习成绩不稳定，还经常来回折腾。直到你 18 岁的时候，高中毕业了，该去社会上闯闯了。于是你就去了年老代，年老代里面人也很多。在年老代里，你生活了 20 年 (每次 GC 加一岁)，最后寿终正寝，被 GC 回收。有一点没有提，你在年老代遇到了一个同学，他的名字叫爱德华 (慕光之城里的帅哥吸血鬼)，他以及他的家族永远不会死，那么他们就生活在永生代。”

具体区域可以通过VisualVM中的VisaulGC插件查看，如图（openjdk 1.7）：






年轻代：是所有新对象产生的地方。年轻代被分为3个部分——Enden区和两个Survivor区（From和to）当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区（假设为from区）。Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区（假设为to区）。这样在一段时间内，总会有一个空的survivor区。经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。需要注意，Survivor的两个区是对称的，没先后关系，from和to是相对的。

年老代：在年轻代中经历了N次回收后仍然没有被清除的对象，就会被放到年老代中，可以说他们都是久经沙场而不亡的一代，都是生命周期较长的对象。对于年老代和永久代，就不能再采用像年轻代中那样搬移腾挪的回收算法，因为那些对于这些回收战场上的老兵来说是小儿科。通常会在老年代内存被占满时将会触发Full GC,回收整个堆内存。

持久代：用于存放静态文件，比如java类、方法等。持久代对垃圾回收没有显著的影响。 

分代回收的效果图如下：



我这里之所以最后讲分代，是因为分代里涉及了前面几种算法。年轻代：涉及了复制算法；年老代：涉及了“标记-整理（Mark-Sweep）”的算法。
--------------------- 
作者：tonytfjing 
来源：CSDN 
原文：https://blog.csdn.net/tonytfjing/article/details/44278233 
版权声明：本文为博主原创文章，转载请附上博文链接！

   1. 判断对象存活情况
      （1）引用计数算法
         优点：判定效率高，实现简单
         缺点：难以解决对象之间相互引用的问题
         JVM 不使用
      （2）可达性分析算法
         特点：GC Roots
   2. 垃圾收集算法
      （1）标记 - 清除算法
         缺点：效率不高，产生大量不连续的碎片
      （2）复制算法
         特点：内存空间划分成两块
         缺点：内存空间缩小一半，对象存活率较高时效率变低；不适用于老年代。
      （3）标记 - 整理算法
         特点：向一端移动，直接清理端边界以外的内存
      （4）分代回收算法
         新生代：复制算法
         老年代：标记 - 清理/整理
   3. HotSpot 算法实现
      核心：根节点枚举，数据结构采用 OopMap
      在特定位置（安全点 SafePoint）记录
      安全区域（SafeRegion）：在一端代码片段之中，引用关系不会发生变化。在这个区域中的任一地方开始 GC 都是安全的
   4. 垃圾回收器
      新生代：Serial、ParNew、Parallel Scavenge
      老年代：CMS、Serial Old（MSC）、Parallel Old
      任意代：G1
      Serial 单线程
      ParNew 多线程版本的 Serial
1. CMS 收集器
   以获取最短回收停顿时间为目标的收集器；常用在互联网或者 B/S 系统的服务端上。【注重服务端的响应速度，希望系统停顿时间最短】

   过程
   初始标记 stw
   并发标记
   重新标记 stw
   并发清除
   缺点一：对 CPU 资源敏感
   i-CMS 增量式并发收集器，适用于CPU数量过少时，收集器线程资源占用率高的情况（已被 deprecated，效率低，不提倡使用）

   缺点二：无法处理浮动垃圾
   缺点三：使用标记 - 清除算法
2. G1 收集器
   > 面向服务端

   并行、并发
   分代收集
   空间整合
   可预测的停顿，建立可预测的停顿时间模型
   过程
   初始标记
   并发标记
   最终标记
   筛选回收
3. 内存分配与回收策略
   对象优先在新生代 Eden区分配，无空间时发起一次 Minor GC
   大对象直接进入老年代
   长期存活的对象将进入老年代（年龄计数器）
   动态对象年龄判断（年龄相对较大直接进入老年代）
   空间分配担保（老年代有足够空间容纳新生代）
4. 关于GC
   新生代：Minor GC
   老年代：Major GC 或 Full GC

---
### 三、内存模型与线程
   1. 优化
      指令重排序
   2. 内存间交互操作
      lock
      unlock
      use
      assign
      load
      store
      read
      write
   3. volatile
      所有线程可见
      禁止指令重排序优化（机器指令增加 lock）
   4. 先行发生关系
      程序次序规则
      管程锁定规则
      volatile 变量规则
      线程启动规则
      线程终止规则
      线程中断规则
      对象终结规则
      传递性
   5. 线程实现
      内核线程（需要系统调用：系统态<->用户态）
      用户线程
      用户线程 + 轻量级进程
      抢占式调度，而不是协同式调度变量
