# [***JVM 规范小结***](https://yq.aliyun.com/articles/619813?utm_content=m_1000008975)

> https://blog.csdn.net/tonytfjing/article/details/44278233

# 一、基础

1. 与 Java 语言
   JVM 与 Java 语言没有必然的联系，只与 class 文件格式有关联。

2. 与 .class 文件
   - class 文件包含了 Java 虚拟机指令集（字节码）和符号表，以及其他辅助信息。
   - JVM 在 class 文件中施加了许多强制性语法和结构化约束。
   - 凡是能用 class 文件正确表达出来的编程语言都可以在 JVM 中执行。

3. 数据类型
   - 原始类型（基本类型），如 int、double、long <---> 原始值
         ① 整数类型
            byte 8位有符号二进制补码整数，默认值为0（下面3个也是）
            short 16位有...
            int 32位有...
            long 64位有...
            char 16位无符号整数表示的、指向基本多文种平面（BMP）的 Unicode 码点，UTF-16 编码，默认为 null（'u0000'）
         ② 浮点数类型
            float 32位单精度（IEEE 754标准）
            double 64位单精度（IEEE 754标准）
         **五个特殊数值**：正数0、负数0、正无穷大、负无穷大、NaN
         除了 NaN 之外，其他值都是 有序的
         有且仅有一个值 NaN 与自身比较返回 false
         任何数字与 NaN 比较都会返回 false
         ③ returnAddress
            值指向虚拟机一个地址
         ④ boolean
         在编译之后一般使用 int 数据类型代替

   - 引用类型，如 reference <---> 引用值
         class type
         array type
         interface type
         数据最外维是 组件类型，最里面维度称为 元素类型。如List，其中List是组件类型，Integer是元素类型。
         顺便一提，Integer具有一个缓冲池 -128~127，默认情况下直接从池中取值（取的值相等则变量地址相同），除非 new Integer(10) 或者取超出范围的值。
> JVM 希望类型检查能在程序运行前（编译阶段）完成。

## 运行时数据区

   1. pc 寄存器
      每个 JVM 线程都有自己的 pc 寄存器
      每个线程只执行一个方法
      容量至少应当能保存一个 returnAddress 类型的数据或者一个与平台相关的本地指针的值

   2. 虚拟机栈(VM stack)
      StackOverflowError 线程请求分配的栈容量超过 JVM 栈允许的最大容量
      OutOfMemoryError 栈可以动态扩展，在尝试扩展时无法申请到足够的内存

   3. 本地方法栈(native method stack)
      支持 native 的执行（其他语言编写的方法）
      抛出StackOverflowError
      抛出OutOfMemoreyError

   4. 堆(heap)
      是可供各个线程共享的 运行时内存区域
      是供所有类实例和数组对象 分配内存 的区域
      所使用的内存，不需要 保证是 连续 的
      抛出OutOfMemoryError

   5. 方法区(method area)
      是可供各个线程共享的 运行时内存区域
      包括【 运行时常量池，字段和方法数据，构造函数和普通方法的字节码内容，在类、实例、接口初始化时用到的特殊方法】
      抛出OutOfMemoryError

   6. 运行时常量池(存放在方法区种)
      class 文件中每一个类或接口的常量池表
      抛出OutOfMemoryError

## 帧栈

   存储数据和部分过程结果的数据结构
   也用来处理动态链接、方法返回值和异常分派
   随着方法调用而创建，随着方法结束而销毁
   为程序提供调试功能
   当前栈帧 - 当前类 - 当前方法
   （1）局部变量表
      索引访问
      long 和 double 的值占用两个连续的局部变量
   （2）操作数栈
      long 和 double 占用两个单位的栈深度
   （3）动态链接
      每个栈帧都包含一个指向当前方法所在类型的运行时常量池的引用
      晚期绑定？

6. 浮点运算
   1. JVM 的浮点操作
      - 遇到被0除、上下限溢出和非精确时，不会抛出错误
      - 不支持 IEEE 754 的信号浮点比较
      - 舍入操作：向最接近数舍入模式，如果无法精确，则舍入到最低有效位为 0 的那个值
      - 浮点数值 -> 整型数值：向零舍入
      - 不支持 IEEE 754 的单精度扩展和双精度扩展格式
   2. 浮点模式
      - 每个方法都有这项属性
      - 分为 FP-strict 模式、非FP-strict模式
      - 体现在 class 文件的方法 method_info 结构的访问标志 access_flags 中的 ACC_STRICT 标志位
      - JDk 1.1以及之前版本的编译器是 非FP-strict模式
   3. 数值集合转换
      - 支持扩展指数集合的 JVM 实现数值在标准浮点数集合与扩展指数集合之间饿映射关系是允许或必要的
      - float => 单精度浮点数集合中的元素
      - double => 双精度浮点数集合中的元素
7. 特殊方法
   （1） 构造方法（初始化方法）
   （2）签名多态性
   由 java.lang.invoke.MethodHandle 类进行声明
   只有一个类型为 Object[] 的形参
   返回值为 Object
   ACC_VARARGS 和 ACC_NATIVE 标志被设置
8. 异常
   1. 同步异常
      athrow 字节码指令被执行
      虚拟机同步检测到程序发生非正常的执行情况
   2. 异步异常
      调用了 Thread 或者 ThreadGroup 的 stop 方法
      JVM 实现发生了内部错误
      每个执行的方法都配备0~多个异常处理器
9. 类库
   需要JVM特殊支持的类
   反射：java.lang.reflect、Class
   加载和创建类或接口的类：ClassLoader
   连接和初始化类或接口：ClassLoader
   安全：java.security
   多线程：Thread
   弱引用：java.lang.ref
10. 公有设计、私有实现
   == 统一设计、各自实现

---

## 垃圾收集器与内存分配策略

   java栈、程序计数器、本地方法栈都是线程私有的，线程生就生，线程灭就灭，栈中的栈帧随着方法的结束也会撤销，内存自然就跟着回收了。所以这几个区域的内存分配与回收是确定的，我们不需要管的。但是java堆和方法区则不一样，我们只有在程序运行期间才知道会创建哪些对象，所以这部分内存的分配和回收都是动态的。一般我们所说的垃圾回收也是针对的这一部分。
   Stack的内存管理是顺序分配的，而且定长，不存在内存回收问题；而Heap 则是为java对象的实例随机分配内存，不定长度，所以存在内存分配和回收的问题

### 内存分配

   Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，减少了系统调用的次数，节省了一定的开销，这有点类似于内存池的概念；

   java一般内存申请有两种：

   **静态内存** : 编译时就能够确定的内存就是静态内存，即内存是固定的，系统一次性分配，比如int类型变量.

   **动态内存** : 动态内存分配就是在程序执行时才知道要分配的存储空间大小，比如java对象的内存空间。

### 垃圾检测方法

1. 引用计数法 : 给一个对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1。
   优点：判定效率高，实现简单
   缺点：难以解决对象之间相互引用的问题

2. 可达性分析算法 : 以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象, 本地方法中引用的对象等。
   特点：GC Roots

### GC 回收算法

1. 标记-清除（Mark-sweep）
   标记所有需要回收的对象，然后统一回收。
   不足：效率低；标记清除之后会产生大量碎片。效果图如下：
2. 复制（Copying）
   此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。
   优点 : 复制成本比较小，不会出现“碎片”问题。
   缺点 : 就是需要两倍内存空间。
3. 标记-整理（Mark-Compact）
   堆内存分为两端, 标记所有被引用对象，遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的另一端，
4. 分代收集算法
   基于不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。将对象按其生命周期的不同划分成：年轻代(Young Generation, 年轻代分为一个 Eden区, 两个survive区(from, to 区))、年老代(Old Generation)、持久代(Permanent Generation)。其中持久代主要存放的是类信息，所以与java对象的回收关系不大，与回收息息相关的是年轻代和年老代。这里有个比喻很形象
   年轻代：是所有新对象产生的地方。年轻代被分为3个部分——Eden区和两个Survivor区（From和to）hotspot默认Eden : Survivor大小比例为8:1:1, Survivor的两个区是对称的，没先后关系，from和to是相对的。
   年老代：在年轻代中经历了N次回收后仍然没有被清除的对象, 通常会在老年代内存被占满时将会触发Full GC,回收整个堆内存。
   持久代：用于存放静态文件，比如java类、方法等。持久代对垃圾回收没有显著的影响。 

   1. 当系统创建一个对象的时候，总是先在Eden区操作，
   2. 第一次Eden区满了就会触发一次YoungGC，也就是年轻代的垃圾回收, 将Eden区还在被使用的对象复制到From区
   3. 当Eden再区满了，那么再触发一次YoungGC，也就是年轻代的垃圾回收。将Eden区与From区还在被使用的对象复制到To区.
   4. 当Eden再区满了, 执行上一条, 在From与To之间来回游荡, From区和to区是相对的
   5. 经过若干次YoungGC后，这时候From区与To区亮出了底线（阈值），此时会将from或to区的对象移动至老年代。
   6. 若干次后, 老年代野蛮了, 执行集体大扫除（Full GC），也就是全量回收。

   > Full GC成本高，使用太频繁的话，无疑会对系统性能产生很大的影响。所以要合理设置年轻代与老年代的大小，尽量减少Full GC的操作




   1. HotSpot 算法实现
      核心：根节点枚举，数据结构采用 OopMap
      在特定位置（安全点 SafePoint）记录
      安全区域（SafeRegion）：在一端代码片段之中，引用关系不会发生变化。在这个区域中的任一地方开始 GC 都是安全的
   2. 垃圾回收器
      新生代：Serial、ParNew、Parallel Scavenge
      老年代：CMS、Serial Old（MSC）、Parallel Old
      任意代：G1
      Serial 单线程
      ParNew 多线程版本的 Serial
5. CMS 收集器
   以获取最短回收停顿时间为目标的收集器；常用在互联网或者 B/S 系统的服务端上。【注重服务端的响应速度，希望系统停顿时间最短】

   过程
   初始标记 stw
   并发标记
   重新标记 stw
   并发清除
   缺点一：对 CPU 资源敏感
   i-CMS 增量式并发收集器，适用于CPU数量过少时，收集器线程资源占用率高的情况（已被 deprecated，效率低，不提倡使用）

   缺点二：无法处理浮动垃圾
   缺点三：使用标记 - 清除算法
6. G1 收集器
   > 面向服务端

   并行、并发
   分代收集
   空间整合
   可预测的停顿，建立可预测的停顿时间模型
   过程
   初始标记
   并发标记
   最终标记
   筛选回收
7. 内存分配与回收策略
   对象优先在新生代 Eden区分配，无空间时发起一次 Minor GC
   大对象直接进入老年代
   长期存活的对象将进入老年代（年龄计数器）
   动态对象年龄判断（年龄相对较大直接进入老年代）
   空间分配担保（老年代有足够空间容纳新生代）
8. 关于GC
   新生代：Minor GC
   老年代：Major GC 或 Full GC

---
### 三、内存模型与线程
   1. 优化
      指令重排序
   2. 内存间交互操作
      lock
      unlock
      use
      assign
      load
      store
      read
      write
   3. volatile
      所有线程可见
      禁止指令重排序优化（机器指令增加 lock）
   4. 先行发生关系
      程序次序规则
      管程锁定规则
      volatile 变量规则
      线程启动规则
      线程终止规则
      线程中断规则
      对象终结规则
      传递性
   5. 线程实现
      内核线程（需要系统调用：系统态<->用户态）
      用户线程
      用户线程 + 轻量级进程
      抢占式调度，而不是协同式调度变量
